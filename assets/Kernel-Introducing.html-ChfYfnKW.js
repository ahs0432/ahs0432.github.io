import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,o,a as c}from"./app-eXCOKstw.js";const i={},n=c(`<div class="hint-container info"><p class="hint-container-title">정보</p><p>📢 개인적인 정리를 위해 가벼운 어투로 내용을 정리하였습니다.</p></div><h2 id="🌠-2025년-마음가짐" tabindex="-1"><a class="header-anchor" href="#🌠-2025년-마음가짐"><span>🌠 2025년 마음가짐</span></a></h2><p>2025년에는 나의 부족한 점을 더 업그레이드 해보자는 마음을 갖게 됐다.<br> 나는 나름 여러 활동을 통해 얕지만 많은 지식을 갖고 있다고 생각하고 있다.</p><p>하지만, 내가 가장 잘하는 하나의 지식을 뽑아보라고 하면 정하기가 어려운 것 같다.<br> 중소기업의 장점이자 단점이 여기서 부각되는데 다양한 경험은 있지만 깊지 못하다.</p><p>그래서 올해부턴 나한테 물어보면 저는 <strong>이 분야의 전문가입니다</strong> 하도록 노력하려 한다.<br><s>(지금은 외부에 나가 이야기할 때 <code>클라우드 엔지니어</code>이자 <code>개발자</code> 지망생이라 한다.)</s></p><p>나는 어렸을 때 <code>시스템 프로그래머</code>를 동경했고 지금도 이 부분은 마찬가지인 상태다.<br> 지금은 기본 Base가 있고 그렇기에 목표에 도달하기에 이보다 더 나은 상태는 없다.</p><p>올해 첫 번째 도전으로 그간 겉핥기만 열심히 했던 <code>Kernel</code>에 대한 학습을 시작한다.<br> 솔직히 <code>Kernel</code>이라는 요소는 <code>개발자</code>, <code>엔지니어</code>에게 필수 지식은 아닐 수 있다.</p><p><code>시스템 프로그래머</code>에게 있어 <code>Kernel</code>에 대한 구조 이해는 기본 중에 기본일 것이고,<br> 시간이 흘러서 이 지식은 나의 기초 체력이자 큰 원동력으로 작용할 것으로 확신한다.</p><h2 id="😀-어떻게-공부할-것인가" tabindex="-1"><a class="header-anchor" href="#😀-어떻게-공부할-것인가"><span>😀 어떻게 공부할 것인가?</span></a></h2><p>먼저 현재는 별세하신 서울대학교의 고건 교수님의 <a href="https://olc.kr/course/course_online_view.jsp?id=35&amp;s_keyword=kernel&amp;x=0&amp;y=0" target="_blank" rel="noopener noreferrer">강의</a>를 수강할 생각이다.</p><p>이런 강의를 조금 더 빠르게 접했다면 좋았을텐데라는 생각이 강하게 들고 있다.<br> 무료로 이정도 학식이 높으신 분의 강의를 접할 수 있다는 것이 정말 좋은 듯 하다.</p><p>시간 여유가 될 때 강의를 시청하고 계속 돌려보며 나의 지식으로 만들고자 한다.<br> 치열했던 2024년이 끝났으니 더 치열한 2025년을 살아보자라는 생각을 한다.</p><p>여기까지 강의를 듣기 전 나의 서론을 마치겠다. 너무 길어서 지루했을 듯 하다.</p><h2 id="😎-introduction" tabindex="-1"><a class="header-anchor" href="#😎-introduction"><span>😎 Introduction</span></a></h2><h3 id="💫-배우기-전에" tabindex="-1"><a class="header-anchor" href="#💫-배우기-전에"><span>💫 배우기 전에</span></a></h3><p><code>Kernel</code>이란 분야는 한 명이 마스터하여 모든 것을 알기란 어려운 분야다.</p><p><code>Linux</code>를 굉장히 잘 다루는 집단으로 유명한 <code>IBM</code>과 같은 공룡 기업에서도<br> 총 250명 정도의 인원으로 각 분야 별 전문가 그룹을 운영하고 있을 정도이다.</p><p>그렇기에 기초를 다질 때에는 <code>Kernel</code>에 대한 모든 구조를 알겠다라는 것보단<br><code>Kernel</code>과 <code>운영체제</code>가 어떻게 설계됐고 그에 대한 원리를 이해하도록 하자.</p><h3 id="☸️-운영체제" tabindex="-1"><a class="header-anchor" href="#☸️-운영체제"><span>☸️ 운영체제</span></a></h3><p><code>운영체제</code>라는 것을 사용자와 컴퓨터 하드웨어 간 중재자 역할을 하는 프로그램이다.<br> 조금 더 정리해보면 <code>하드웨어 자원</code>을 관리하고 사용자에게 지원하는 서비스이다.</p><div class="hint-container info"><p class="hint-container-title">정보</p><p>🦾 <strong>하드웨어 자원의 종류?</strong><br><code>하드웨어</code>는 굉장히 다양한 종류가 존재하는데 대표적으로 아래와 같이 이뤄져 있다.</p><ul><li><code>CPU</code>(<code>Central Process Unit</code>, <code>중앙처리장치</code>): 기억, 해석, 연산, 제어 수행</li><li><code>Memory</code>(<code>주기억장치</code>): <code>CPU</code>와 <code>Disk</code> 간 속도 차이 해소 / <code>휘발성</code> / <code>RAM</code></li><li><code>Disk</code>(<code>보조기억장치</code>): 실제 데이터를 저장하는 공간 / <code>비휘발성</code> / <code>SSD</code>, <code>HDD</code></li><li><code>TTY</code>(<code>TeleTYpewriter</code>): <code>Console</code> 및 <code>Terminal</code> 모드를 의미 <ul><li><code>TTS</code>(<code>TTy Serial</code>): <code>Console</code>을 이용한 물리적인 접근을 지원</li><li><code>PTY</code>(<code>Pseudo-Terminal</code>): Pseudo(가상)의 <code>Teminal</code> 모드 (<code>CLI</code>)</li><li><code>PTS</code>(<code>Pseudo-Terminal Slave</code>): Pseudo(가상)의 <code>Teminal</code> 모드 (<code>GUI</code>)</li></ul></li></ul><p>이외에도 다양한 <code>하드웨어</code>가 있고 이러한 자원을 <code>운영체제</code>에서 관리하게 된다.</p></div><h4 id="목표" tabindex="-1"><a class="header-anchor" href="#목표"><span>목표</span></a></h4><p><code>운영체제</code>의 목표는 간단하게 4가지로 정리하여 설명할 수 있다.</p><ul><li>사용자의 프로그램을 실행한다.</li><li>사용자 문제를 더 쉽게 해결할 수 있도록 지원한다.</li><li>컴퓨터 시스템을 편리하게 사용할 수 있도록 제공한다.</li><li>하드웨어를 더욱 효율적으로 사용할 수 있도록 한다.</li></ul><h4 id="성능-지표" tabindex="-1"><a class="header-anchor" href="#성능-지표"><span>성능 지표</span></a></h4><p>결국 목표에 대한 달성에 대한 부분을 평가하기 위해서는 지표가 필요할 것이다.<br><code>운영체제</code>에서 사용하게 되는 지표는 대표적으로 아래의 3가지가 존재할 것이다.</p><ul><li><code>처리량</code>(<code>Throughput</code>): 작업/초 (<code>시스템 중심</code>)</li><li><code>활용도</code>(<code>Utilization</code>): 사용 시간의 비율 (<code>사용자 중심</code>)</li><li><code>응답시간</code>(<code>Response Time</code>): 작업 당 시간 (<code>사용자 중심</code>)</li></ul><p>지표는 <code>사용자 중심</code>과 <code>시스템 중심</code>으로 나눌 수 있는데 서로 충돌될 수 있다.</p><h4 id="구조" tabindex="-1"><a class="header-anchor" href="#구조"><span>구조</span></a></h4><p><code>사용자</code> → <code>응용 프로그램</code> → <code>운영체제</code> → <code>하드웨어</code></p><p>구조를 보면 이해할 수 있겠지만 <code>사용자</code>가 <code>응용 프로그램</code>을 사용하게 될 경우<br><code>운영체제</code>를 통해 <code>하드웨어</code>를 이용한 요청을 수행한다는 것을 확인할 수 있다.</p><h3 id="👨‍💻-프로그램" tabindex="-1"><a class="header-anchor" href="#👨‍💻-프로그램"><span>👨‍💻 프로그램</span></a></h3><p><code>프로그램</code>은 어떠한 일을 수행하기 위해 작성된 순서나 목록 등을 의미하게 되는데,<br> 다양한 기능들의 <code>함수</code>(<code>명령</code>)를 이용하여 순서나 목록을 작성한 집합체라 볼 수 있다.</p><ul><li>대표적으로 <code>C Language</code>를 이용하여 코드 작성 시 <code>*.c</code> 파일을 작성하게 되는데,<br> 이를 <code>컴파일</code>(<code>Compile</code>)한 <code>a.out</code>, <code>a.exe</code> 등의 목적 파일을 프로그램이라 칭함</li></ul><h4 id="프로그램의-비효율성" tabindex="-1"><a class="header-anchor" href="#프로그램의-비효율성"><span>프로그램의 비효율성</span></a></h4><p>우리가 많이 사용하는 Microsoft 사에서 개발한 <code>Office</code>라는 프로그램을 생각해보자.</p><p><code>Office</code>는 하나의 프로그램이 아닌 <code>Word</code>, <code>Excel</code>, <code>Powerpoint</code> 등으로 분리돼있다.<br><strong>왜 그렇게 분리 해두었을까?</strong> 다양한 이유가 있겠지만 <code>비효율성</code>이 클 것이라 생각된다.<br><s>(물론 사업적인 목적에서 분리하여 별도로 판매하려는 목적도 있을 것이라 생각한다.)</s></p><p><code>프로그램</code>이 커지게 되면 실행하게 될 때 <code>하드웨어</code>에 부담되는 <code>사용량</code>이 증가한다.<br> 그렇게 된다면 자원 사용량이 늘어나니 당연하게도 <strong>동작 속도의 저하로 이어지게 된다.</strong></p><p>사람으로 비유해보면 한 사람에게 불필요한 업무까지 모두 전달하는 경우로 볼 수 있다.</p><h4 id="운영체제의-프로그램-분리" tabindex="-1"><a class="header-anchor" href="#운영체제의-프로그램-분리"><span>운영체제의 프로그램 분리</span></a></h4><p><code>프로그램</code>이 하나의 큰 요소에서 <code>비효율성</code>이 있다면 <code>운영체제</code>도 마찬가지일 것이다.<br> 이러한 <code>비효율성</code>을 해소하기 위해 <code>운영체제</code>도 여러 요소로 분리하여 제공하고 있다.</p><p>대표적인 요소로 <code>Kernel</code>, <code>Utility</code>, <code>Shell</code>, <code>File</code>, <code>Standard File</code> 정도가 있다.</p><h3 id="🏁-kernel-커널" tabindex="-1"><a class="header-anchor" href="#🏁-kernel-커널"><span>🏁 Kernel / 커널</span></a></h3><p><code>Kernel</code>은 본질적으로 <code>C Language</code>로 만들어진 <code>프로그램</code>에 해당하는 요소이다.<br> 다른 것과 무슨 차이점이 있길래 <code>Kernel</code>이라는 별도의 요소로 부르게 된 것일까?</p><p>바로 <code>Memory Resident</code>하다는 특징을 가지고 있기 때문에 별도로 구분하게 된다.<br><code>Memory Resident</code>는 직역하게 되면 <code>메모리 거주자</code>(?)정도라고 이야기할 수 있다.</p><p><code>Kernel</code>은 다른 <code>프로그램</code>과 다르게 <code>Memory</code>에 항상 상주(점유)하고 있게 된다.<br> 그렇기 때문에 무언가 처리가 필요할 때 즉각적으로 대응할 수 있다는 특징이 있다.</p><p>그렇다면 <code>Kernel</code> 외의 <code>프로그램</code>은 어떠한 특징을 가지고 있다고 볼 수 있을까?<br> 눈치챈 사람도 있겠지만 <code>Disk Resident</code>한 특징을 갖고 있다고 이야기할 수 있다.</p><p>다른 <code>프로그램</code>은 <code>Disk</code>에 있다가 필요한 경우 <code>Memory</code>에 상주하여 처리한다.</p><h3 id="📻-utility-유틸리티" tabindex="-1"><a class="header-anchor" href="#📻-utility-유틸리티"><span>📻 Utility / 유틸리티</span></a></h3><p><code>Utility</code>는 <code>Kernel</code>에서 알아본 바와 같이 <code>Disk Resident</code>한 특징을 갖는다.<br> 필요한 경우에 <code>Disk</code>에서 <code>Memory</code>로 상주시키고 종료되면 회수된다는 것이다.</p><p>우리가 <code>CLI</code> 환경에서 필요한 경우 호출되고 사용하는 요소가 무엇이 있을까?<br> 그렇다 바로 <code>Command</code>라는 요소가 존재하는데, <code>Utility</code>와 동의어로 본다.<br> (보통 <code>Linux</code>에서 <code>Command</code>라는 것은 <code>/bin/</code> 경로 하위에 위치하게 된다.)</p><p>그리고 이것은 하나의 <code>Job</code>(<code>작업</code>)이라고도 이야기할 수 있다.<br> (<code>Utility</code> = <code>Command</code> = <code>Job</code>이라는 관계로 볼 수 있다.)</p><h3 id="🖥️-shell-쉘" tabindex="-1"><a class="header-anchor" href="#🖥️-shell-쉘"><span>🖥️ Shell / 쉘</span></a></h3><p><code>Shell</code>은 <code>Utility</code>지만 <code>Job Control</code>(<code>작업 제어</code>)라는 특징을 갖는다.<br> 이전에 <code>Utility</code>는 하나의 <code>Job</code>이라고 부를 수 있다고 이야기 했었다.</p><p><code>Shell</code>은 <code>Utility</code>를 제어하는 역할을 수행한다고 볼 수 있는 것이다.<br> (<code>Command</code>마다 처리를 진행하므로 <code>Interpreter</code> 역할이라 볼 수 있다.)</p><p>주된 역할은 키보드 입력을 읽고 명령을 실행하고 결과를 반환하게 된다.<br><code>사용자</code>와 <code>UNIX/Linux</code> 간의 인터페이스 역할을 수행한다고 볼 수 있다.</p><h3 id="📁-file-파일" tabindex="-1"><a class="header-anchor" href="#📁-file-파일"><span>📁 File / 파일</span></a></h3><p><code>Sequence of Bytes</code>로 <strong>바이트의 연속체(배열)</strong> 정도로 해석이 가능하다.<br> 정보의 이름이 지정된 집합체 정도로 블록과 같은 제약이 존재하지 않는다.</p><p>또한 <code>Linux</code>와 같은 <code>운영체제</code>는 <strong>I/O Device</strong>도 <code>File</code>로 취급하게 된다.<br><code>Linux</code> 시스템 상 <code>/dev/</code> 하위에는 **특수 파일(Special files)**이 있다.</p><ul><li>예) <code>/dev/xvda</code>, <code>/dev/tty0</code></li></ul><h3 id="⌨️-standard-file-표준-파일" tabindex="-1"><a class="header-anchor" href="#⌨️-standard-file-표준-파일"><span>⌨️ Standard File / 표준 파일</span></a></h3><p><code>Linux</code>와 같은 <code>운영체제</code>는 I/O Device도 <code>File</code>로 취급한다는 걸 알게 됐다.</p><p>이러한 표준 형식으로 제공되는 요소를 <code>Standard File</code>이라고 일컫게 되는데,<br> 보통은 <code>표준 입력</code>, <code>표준 출력</code>, <code>표준 오류</code>와 같이 3가지 요소로 나누게 된다.</p><ul><li><code>표준 입력</code>(<code>Standard Input</code>): 키보드</li><li><code>표준 출력</code>(<code>Standard Output</code>): 화면</li><li><code>표준 오류</code>(<code>Standard Error</code>): 오류 메시지</li></ul><h3 id="🧵-kernel-shell-utility-관계" tabindex="-1"><a class="header-anchor" href="#🧵-kernel-shell-utility-관계"><span>🧵 Kernel - Shell - Utility 관계</span></a></h3><p>이 세 요소에 대한 관계를 이해하기 위해서는 전개되는 과정을 이해할 필요가 있다.</p><ul><li><code>Booting</code>을 통해 시스템을 실행한다. <ul><li><code>Kernel</code>이 실행되어 <code>Memory</code>에 상주한다.</li></ul></li><li><code>Shell</code>을 이용하여 사용자가 접근하게 된다. <ul><li><code>Kernel</code> 하위에 <code>Child Process</code>로 <code>Shell</code>이 실행된다.</li><li><code>Shell</code>도 마찬가지로 <code>Memory</code>에 상주하게 된다.</li><li><code>사용자</code>가 <code>Command</code>를 입력할 때까지 대기한다.</li></ul></li><li><code>Utility</code>(<code>Command</code>)를 실행한다. <ul><li><code>Shell</code> 하위에 <code>Child Process</code>로 <code>Utility</code>가 실행된다.</li><li><code>Utility</code>도 <code>Memory</code>에 상주하고 <code>Job</code>이 끝나면 회수된다.</li></ul></li><li><code>사용자</code>가 모든 작업을 끝내고 <code>Shell</code>을 종료한다. <ul><li><code>Shell</code>이 상주했던 <code>Memory</code>가 회수된다.</li></ul></li></ul><p>이 과정으로 보면 아래와 같은 Tree 구조 형태를 가지게 된다고 볼 수 있다.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Kernel</span></span>
<span class="line"><span>├── Shell (1)</span></span>
<span class="line"><span>│   ├── Utility (2-1)</span></span>
<span class="line"><span>│   └── Utility (2-2)</span></span>
<span class="line"><span>└── Shell (2)</span></span>
<span class="line"><span>    ├── Utility (2-1)</span></span>
<span class="line"><span>    └── Utility (2-2)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="🤔-windows와-linux의-관점-차이" tabindex="-1"><a class="header-anchor" href="#🤔-windows와-linux의-관점-차이"><span>🤔 Windows와 Linux의 관점 차이</span></a></h3><p>그렇다면 최근 사용자들이 사용하는 대표적인 <code>운영체제</code> 두 개를 비교해보자.<br> 당연하게도 개인 사용자가 가장 많은 것은 <code>Windows</code> 서버는 <code>Linux</code>일 것이다.</p><h4 id="windows" tabindex="-1"><a class="header-anchor" href="#windows"><span>Windows</span></a></h4><p><code>Windows</code>의 경우 사용자에 초점을 맞춘 <code>Personal Computer</code>에 초점을 맞춘다.<br> 그렇기 때문에 <code>CPU</code>, <code>Memory</code> 등의 자원은 <code>단일 사용자</code>를 위해서 사용되게 된다.</p><p><code>단일 사용자</code>에 초점을 맞춰 환경을 제공하기에 편리하도록 <code>GUI</code>의 특징을 갖는다.<br> (<code>GUI</code>(<code>Graphic User Interface</code>): 입출력 장치를 이용하여 아이콘 등을 클릭/사용)</p><p>이러한 서비스 지향성을 <code>Single user system</code> 기반으로 설계됐다고 말할 수 있다.<br> 이렇게 됐을 때 <code>Windows</code>에 대한 주요한 특징은 아래와 같이 3가지로 정리된다.</p><ul><li>특징 <ul><li><code>Single user system</code></li><li>단일 사용자를 위한 설계로 개인 사용자의 편리함을 우선으로 설계</li><li>자원 사용량의 경우 개인 사용자를 초점으로 두기에 전반적으로 사용</li></ul></li></ul><h4 id="linux" tabindex="-1"><a class="header-anchor" href="#linux"><span>Linux</span></a></h4><p>그렇다면 <code>Linux</code>는 어떨까? 일반적으로 <code>Linux</code>의 경우 <code>CLI</code>를 기반으로 사용한다.<br> (<code>CLI</code>(<code>Command Line Interface</code>): 명령 줄을 기반으로 입력한 결과를 출력/확인)</p><p><code>Linux</code>의 경우 방향성 자체가 <code>다중 사용자</code> 즉 <code>Multi user system</code>을 지향한다.<br> 다중의 사용자를 위한 것이므로 <code>자원</code>의 사용량도 최소화하여 운용할 필요가 있다.</p><p>예를 들어 사용자가 3명이 있다고 한다면 1명이 너무 많은 자원을 점유하게 될 경우<br> 다른 2명의 사용자에 피해를 줄 수 있기 때문에 최대한 빠른 자원 회수가 필요하다.</p><p><code>Linux</code>에서 <code>Windows</code>와의 차이가 있는 특징으로는 아래와 같이 3가지가 있다.</p><ul><li>특징 <ul><li><code>Multi user system</code></li><li>다중 사용자를 위한 설계로 다른 사용자에게 피해를 주지 않도록 설계</li><li>자원 사용량의 경우 다중 사용자를 위해 빠르게 사용하고 회수되도록 제공</li></ul></li></ul><p><code>Linux</code>의 경우 <code>Multi user system</code>이라면 과연 <code>보안</code>은 어떻게 해결할까?<br> 같이 사용하는 환경에서 버그나 크래킹이 발생된다면 다른 사용자도 문제가 된다.</p><p>이외에 내가 아닌 다른 사용자가 내 파일을 수정/삭제한다면 문제가 있을 것이다.</p><p>이런 현상이 발생된다면 <code>Memory</code>나 <code>Disk</code>에 쓰였기에 복구가 불가하게 된다.<br> 그렇기 때문에 <code>Linux</code>에서는 <code>Prevent</code>(<code>사전방지</code>)를 하도록 설계가 진행됐다.</p><p><code>Linux</code>는 이런 현상 해소를 위해 사용자의 <code>I/O Instruction</code> 자체를 막아버렸다.</p><p>그렇다면 사용자는 과연 <code>Linux</code>에서 <code>I/O</code> 관련 작업을 어떻게 수행해야할까?<br> 이에 대해서는 <code>CPU</code>를 할당하는 방식에 대해서 먼저 알아보고 알아보도록 하자.</p><h3 id="🪣-cpu-자원의-할당" tabindex="-1"><a class="header-anchor" href="#🪣-cpu-자원의-할당"><span>🪣 CPU 자원의 할당</span></a></h3><p>컴퓨터에서 두뇌 역할을 하는 <code>CPU</code> 자원은 다른 자원에 비해 더욱 한정적이기에<br><code>운영체제</code> 내에서 적합하게 자원을 공유하고 나눠서 사용해야하는 특징이 있다.</p><p><code>CPU</code> 자원은 하나의 순간(<code>Clock</code>)에 하나의 프로세스만 점유가 가능하게 되고,<br> 최근의 <code>CPU</code>는 1초에 40억 번(<code>4.0 Ghz</code>) 이상의 연산을 수행할 수 있게 된다.</p><p>우리가 <code>PC</code>를 사용할 때 마치 <code>Multi Tasking</code>을 할 수 있다고 느끼는 이유도<br> 일반적으로 생각하는 것보다 더 많은 순간을 <code>PC</code>가 빠르게 처리하기 때문이다.</p><p>이 과정에서 아까 말한 허용되지 않은 사용자의 <code>I/O</code>요청이 오면 어떻게 될까?<br> 당연하게도 그냥 실행된다면 방지 요소가 없기에 시스템 자체에 문제가 될 것이다.</p><p>하지만, <code>Linux</code>는 사용자가 요청한 것이 확인되면 바로 <code>CPU</code> 할당을 해제한다.<br> 그렇게 <code>Kernel</code>만이 <code>I/O Instruction</code>을 수행할 수 있도록 환경을 구성한다.</p><h3 id="😅-linux의-i-o-instruction-요청기" tabindex="-1"><a class="header-anchor" href="#😅-linux의-i-o-instruction-요청기"><span>😅 Linux의 I/O Instruction 요청기</span></a></h3><p>사용자의 <code>I/O Instruction</code>이 제한된다고 한다면 <code>I/O</code>는 어떻게 일어날까?<br> 바로 사용자가 <code>I/O</code>를 하는 것이 아니라 <code>Kernel</code>에게 별도 요청을 보내게 된다.</p><p><code>Kernel</code>에 요청은 미리 정해진 <code>Function</code>(<code>함수</code>)를 이용하여 전달할 수 있다.<br> 이러한 과정을 <code>System calls</code>라고 부르고 모든 <code>I/O</code> 작업은 이를 통한다.</p><p>만약 내가 <code>a.out</code>이라는 목적 파일을 실행했을 때를 예를 들어 과정을 보겠다.</p><ol><li><code>Instruction</code>(<code>명령</code>): 사용자가 <code>I/O</code> 관련 명령을 수행해야 한다.</li><li><code>Function</code>(<code>함수</code>): 요청 위탁을 위해 <code>System calls</code>을 발생시킨다.</li><li><code>Process</code>(<code>처리</code>): <code>Memory</code>, <code>File</code> 등의 <code>I/O</code> 요청을 수행한다.</li></ol><h4 id="mode-bit" tabindex="-1"><a class="header-anchor" href="#mode-bit"><span>Mode bit</span></a></h4><p>이러한 <code>System calls</code>의 구분을 위해 <code>CPU</code>는 <code>Mode bit</code>를 갖고 있다.<br> 1 bit는 0과 1을 표현할 수 있고 각 숫자는 다음과 같은 의미를 갖게 된다.</p><ul><li>0 = <code>User</code><ul><li>사용자에 할당된 <code>Address space</code>에만 접근 가능</li><li><code>I/O Instruction</code>, <code>특수 레지스터 접근</code> 등의 제약 존재 <ul><li><code>Add</code>, <code>Sub</code> 등의 명령에만 접근 가능</li></ul></li></ul></li><li>1 = <code>Kernel</code><ul><li>모든 <code>Address space</code>에 접근할 수 있는 권한 보유</li><li>모든 <code>Instruction</code>을 수행할 수 있도록 허용</li></ul></li></ul><p><code>CPU</code>는 <code>Instruction</code>을 위해서는 <code>Memory</code>에 접근이 필요하게 되는데,<br> 위에서 언급한 <code>Mode bit</code> 상태가 무엇인지에 따라 검사 여부를 결정한다.<br> (<code>User</code>인 경우에는 검사가 필요하지만 <code>Kernel</code>인 경우는 불필요하다.)</p><p>검사 과정에서 <code>MMU</code>(<code>Memory Management Unit</code>)이라는 요소가 사용되는데,<br> 이는 하드웨어에 내장된 장치로 <code>CPU</code> ⇄ <code>Memory</code> 사이 <code>Bus</code>를 검사하게 된다.</p><p><code>Instruction</code> 수행 과정은 아래와 같이 5가지인데 한 번 살펴보도록 하자.</p><ol><li><code>PC</code>(<code>Program Counter</code>)에서 <code>Memory</code>에 데이터 요청 (<code>PC to Memory</code>)</li><li><code>Instruction</code> 가져오기 (<code>Instruction Fetch</code>)</li><li>해독하기 (<code>Decode</code>)</li><li>실행하기 (<code>Execute</code>)</li><li><code>PC</code>의 Counting 증가 (<code>Increment PC</code>)</li></ol><p>이 과정에서 두 번의 검사를 수행하는데 먼저 1번 <code>Memory</code>에 데이터 요청이다.<br> 데이터 요청에선 사용자의 접근 가능 <code>Address space</code>인지를 판단하게 된다.</p><p>다음은 3에서 4로 넘어가는 구간에서 <code>op-code</code>를 검사하는 과정이 존재한다.<br> 사용자 모드에서 허용되지 않는 <code>op-code</code>를 시도하는지를 판단하게 된다.</p><p>만약 이를 위배하게 되면 <code>TRAP</code>을 발생하여 <code>Instruction</code>을 멈추게 된다.</p><h4 id="cpu의-memory-요청-예시" tabindex="-1"><a class="header-anchor" href="#cpu의-memory-요청-예시"><span>CPU의 Memory 요청 예시</span></a></h4><p>그렇다면 <code>CPU</code>는 과연 어떻게 <code>Memory</code>에 요청하고 명령을 실행하게 될까?<br> 일단 이를 알아보기 전에 <code>CPU</code>와 <code>Memory</code>가 어떤 요소를 갖고 있는지 봐야한다.</p><ul><li><code>CPU</code><ul><li><code>Control Unit</code><ul><li><code>PC</code>(<code>Program Counter</code>) / <code>특수 레지스터</code></li><li><code>IR</code>(<code>Instruction Register</code>) / <code>특수 레지스터</code></li></ul></li><li><code>ALU</code>(<code>Arithmetic Logic Unit</code>, 산술논리장치)</li></ul></li><li><code>Memory</code><ul><li><code>MAR</code>(<code>Memory Address Register</code>)</li><li><code>MBR</code>(<code>Memory Buffer, Register</code>)</li></ul></li></ul><p>위처럼 <code>CPU</code>와 <code>Memory</code>가 구성된 상태일 때 데이터를 어떻게 처리하게 될까?</p><ol><li><code>PC</code>가 <code>Instruction</code>에 필요한 <code>Address</code>를 <code>Memory</code>의 <code>MAR</code>에게 전달한다.</li><li>이때 읽어들인 <code>Address</code>에 할당된 데이터를 <code>MBR</code>이 <code>IR</code>에게 전달한다.</li><li><code>CPU</code>는 <code>op-code</code>+<code>operands</code> 형태를 만들어 <code>ALU</code>에 전달한다.</li><li><code>operands</code>에서 필요한 <code>Address</code>를 <code>Memory</code>의 <code>MAR</code>에 요청한다. (1~2 과정)</li></ol><p>이때 <code>op-code</code>+<code>operands</code>는 아래와 같은 구조를 가지고 있게 된다.</p><table><thead><tr><th style="text-align:center;">op-code</th><th style="text-align:center;">operands</th><th style="text-align:center;">operands</th></tr></thead><tbody><tr><td style="text-align:center;">add</td><td style="text-align:center;">i</td><td style="text-align:center;">j</td></tr></tbody></table><h4 id="kernel-mode로의-전환-chmodk" tabindex="-1"><a class="header-anchor" href="#kernel-mode로의-전환-chmodk"><span>Kernel mode로의 전환 (chmodk)</span></a></h4><p>이제 <code>CPU</code>가 <code>Memory</code>에 상주된 데이터를 받아오는 방법과 구조를 파악하였다.<br> 이전 이야기한 것처럼 사용자는 <code>I/O</code> 요청을 할 수 없는데 어떻게 진행하게 될까?</p><p>바로 <code>chmodk</code>(<code>Change Mode Kernel</code>)이란 일련의 과정을 이용해서 가능하게된다.</p><p><code>C Lang</code>을 이용하여 간단한 <code>print</code> 구문을 작성하여 메시지를 출력했다고 하자.<br> 이 과정에 당연하게도 <code>I/O</code>가 발생되는데, <strong>그럼 사용자가 요청한게 아닌가?</strong> 할거다.</p><p>하지만 실제 <code>Compile</code>이 완료된 <code>Binary</code> 파일을 확인할 경우에 <code>I/O</code> 요청은 없다.</p><p><code>Compile</code> 하기 전에는 간단하게 <code>I/O</code>를 요청하겠다는 구문으로만 작성해보겠지만,<br> 실제 <code>Compiler</code>는 해당 요청을 <code>chmodk</code>가 가능하도록 내용을 치환하여 제공한다.</p><ul><li>컴파일 이전 <ul><li><code>I/O Instruction</code> 내용 기재</li></ul></li><li>컴파일 이후 <ul><li><code>Prepare all parameters</code> (사전 정의된 파라미터) <ul><li><code>Open, Read, Write ...</code></li></ul></li><li><code>Execure chmodk</code> (<code>chmodk</code> 명령 호출)</li></ul></li></ul><p>그렇다면 <code>chmodk</code>는 실질적으로 수행되는 과정이 어떻게 되는지 알아보도록 하자.</p><p><code>chmodk</code>를 사용자가 호출했다. 생각해보자 해당 <code>Instruction</code>도 위험하지 않을까?<br> 그렇기 때문에 사용자에겐 <code>chmodk</code>도 마찬가지로 <code>privileged instruction</code> 이다.</p><p>만약 사용자가 해당 <code>Instruction</code>을 실행할 경우엔 사용자를 <code>TRAP</code> 상태로 변경한다.<br><code>TRAP</code>이란 <code>User mode</code>에서 실행할 수 없도록 <code>CPU</code> 권한을 회수하는 것을 의미한다.</p><div class="hint-container info"><p class="hint-container-title">정보</p><p><code>Interupt</code>와 <code>TRAP</code>의 차이</p><ul><li><code>Interupt</code>는 <code>HW</code>에 의해 생성된 변경되는 흐름이라고 볼 수 있다.</li><li><code>TRAP</code>은 <code>SW</code>에 의해 호출된 <code>Interupt</code>라 볼 수 있고 <code>Interupt</code>보다 작은 개념이다. <ul><li><code>TRAP</code>은 <code>CPU mode</code> 및 상태를 변경할 수 있지만 <code>Interupt</code>는 상태를 유지한다.</li></ul></li></ul></div><p><code>TRAP</code> 상태가 된다면 <code>Kernel</code>에서 처리하게 되는 <code>TRAP Handler</code>에 진입하게 된다.<br> 이때 <code>Prepare all parameters</code>에 정의된 처리하고자 하는 사항이 무엇인지 확인한다.</p><p>해당 요청사항에 대해 사용자가 권한(<code>Permission</code>)을 보유하고 있는지 확인한 뒤,<br> 전달받은 <code>Parameter</code>와 <code>Memory</code> 요청을 수행한 뒤 다시 <code>TRAP</code>으로 복귀하게 된다.</p><p>복귀된 <code>TRAP</code>은 <code>프로그램</code>으로 돌아와 <code>User mode</code>로 <code>CPU mode bit</code>를 변경한다.</p><h4 id="최종-정리" tabindex="-1"><a class="header-anchor" href="#최종-정리"><span>최종 정리</span></a></h4><p>위에서 설명된 과정과 같이 모든 프로그램은 <code>User mode</code>와 <code>Kernel mode</code>를 오간다.</p><p>처음 <code>User mode</code>에서 <code>Instruction</code>을 수행하여 <code>Kernel mode</code>가 되어 수행하게 되고<br> 사용자의 권한을 검증한 뒤 수행이 완료된다면 <code>TRAP</code>으로 돌아와 <code>User mode</code>가 된다.</p><p>이 과정에서 <code>Function</code> 실행 간 필요한 <code>Local variable</code>이 존재하기 나름일 것이다.<br> 이 변수를 모두 <code>Memory</code>에 미리 상주시켜 놓는 것은 많은 자원 낭비가 발생될 것이다.</p><p>그렇기 때문에 <code>User</code>, <code>Kernel</code> 둘 다 모두 <code>Stack</code> 형태로 저장소를 보유하고 있다.</p><h3 id="🛹-linux-manual-읽기" tabindex="-1"><a class="header-anchor" href="#🛹-linux-manual-읽기"><span>🛹 Linux Manual 읽기</span></a></h3><p><code>Linux</code>에서 명령어의 설명을 보고 싶을 때에는 <code>man</code> 명령어를 이용하면 된다.<br> 그런데 여기서 표기되는 정보에 따라 어떤 형태인지 구분하여 확인할 수 있다.</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> man</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cat</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CAT(1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)                           User Commands                          CAT(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">NAME</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">       cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> concatenate</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> files</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> and</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> print</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> on</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> the</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> standard</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> output</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">..</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> man</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> chown</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chown(2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)                      System Calls Manual                     chown(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">NAME</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">       chown,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fchown,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lchown,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fchownat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> change</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ownership</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> of</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> a</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> file</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">..</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> man</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sleep</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep(3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)                   Library Functions Manual                   sleep(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">NAME</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">       sleep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sleep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> for</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> a</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> specified</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> number</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> of</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> seconds</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">..</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이러한 구분을 <code>Sections</code>라고 일컫고 일반적으로 8가지로 구분되어 제공된다.</p><ol><li>General commands</li><li>System calls</li><li>Library functions</li><li>Special files (Device)</li><li>Files Format</li><li>Game &amp; Screensavers</li><li>Miscellaneous</li><li>System administration commands and daemons</li></ol><hr><p>아직 이게 1강인게 놀랍습니다. 소개에 대한 부분만 이정도의 분량이 나오게 되네요.<br> 얼마나 깊고 심오한 세상일까 다시 한번 놀라면서 더 열심히 하자는 생각이 듭니다.</p><p>하루 1시간 정도씩 썼지만 1강을 정리하는데에만 약 일주일이 소요됐네요.<br> 굉장히 긴 내용이다 보니 직접 강의를 들어보시는 것을 추천드립니다.</p><p>긴 포스팅을 읽어주셔서 감사합니다! 😄 이번 한 해도 파이팅 입니다.</p>`,143),l=[n];function s(a,t){return o(),d("div",null,l)}const h=e(i,[["render",s],["__file","Kernel-Introducing.html.vue"]]),u=JSON.parse('{"path":"/posts/Computing/OS/Linux/Kernel/Kernel-Introducing.html","title":"[Kernel] Linux Kernel 기초 [1]","lang":"ko-KR","frontmatter":{"title":"[Kernel] Linux Kernel 기초 [1]","categories":["Linux"],"tags":["Linux","Kernel","Introduce","커널","리눅스","OS","운영체제","Operating System","시스템","시스템 프로그래밍","프로그램","System","System call","System calls","HW","하드웨어"],"date":"2025-01-18T00:00:00.000Z","order":101,"editLink":false,"lastUpdated":true,"description":"정보 📢 개인적인 정리를 위해 가벼운 어투로 내용을 정리하였습니다. 🌠 2025년 마음가짐 2025년에는 나의 부족한 점을 더 업그레이드 해보자는 마음을 갖게 됐다. 나는 나름 여러 활동을 통해 얕지만 많은 지식을 갖고 있다고 생각하고 있다. 하지만, 내가 가장 잘하는 하나의 지식을 뽑아보라고 하면 정하기가 어려...","head":[["meta",{"property":"og:url","content":"https://blog.false.kr/posts/Computing/OS/Linux/Kernel/Kernel-Introducing.html"}],["meta",{"property":"og:site_name","content":"찬스의 개발 블로그 : Chance Devlog"}],["meta",{"property":"og:title","content":"[Kernel] Linux Kernel 기초 [1]"}],["meta",{"property":"og:description","content":"정보 📢 개인적인 정리를 위해 가벼운 어투로 내용을 정리하였습니다. 🌠 2025년 마음가짐 2025년에는 나의 부족한 점을 더 업그레이드 해보자는 마음을 갖게 됐다. 나는 나름 여러 활동을 통해 얕지만 많은 지식을 갖고 있다고 생각하고 있다. 하지만, 내가 가장 잘하는 하나의 지식을 뽑아보라고 하면 정하기가 어려..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2025-01-20T14:23:05.000Z"}],["meta",{"property":"article:author","content":"Chance"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:tag","content":"Kernel"}],["meta",{"property":"article:tag","content":"Introduce"}],["meta",{"property":"article:tag","content":"커널"}],["meta",{"property":"article:tag","content":"리눅스"}],["meta",{"property":"article:tag","content":"OS"}],["meta",{"property":"article:tag","content":"운영체제"}],["meta",{"property":"article:tag","content":"Operating System"}],["meta",{"property":"article:tag","content":"시스템"}],["meta",{"property":"article:tag","content":"시스템 프로그래밍"}],["meta",{"property":"article:tag","content":"프로그램"}],["meta",{"property":"article:tag","content":"System"}],["meta",{"property":"article:tag","content":"System call"}],["meta",{"property":"article:tag","content":"System calls"}],["meta",{"property":"article:tag","content":"HW"}],["meta",{"property":"article:tag","content":"하드웨어"}],["meta",{"property":"article:published_time","content":"2025-01-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-20T14:23:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[Kernel] Linux Kernel 기초 [1]\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-01-20T14:23:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Chance\\",\\"url\\":\\"https://blog.false.kr\\",\\"email\\":\\"chance0432@naver.com\\"}]}"]]},"headers":[{"level":2,"title":"🌠 2025년 마음가짐","slug":"🌠-2025년-마음가짐","link":"#🌠-2025년-마음가짐","children":[]},{"level":2,"title":"😀 어떻게 공부할 것인가?","slug":"😀-어떻게-공부할-것인가","link":"#😀-어떻게-공부할-것인가","children":[]},{"level":2,"title":"😎 Introduction","slug":"😎-introduction","link":"#😎-introduction","children":[{"level":3,"title":"💫 배우기 전에","slug":"💫-배우기-전에","link":"#💫-배우기-전에","children":[]},{"level":3,"title":"☸️ 운영체제","slug":"☸️-운영체제","link":"#☸️-운영체제","children":[]},{"level":3,"title":"👨‍💻 프로그램","slug":"👨‍💻-프로그램","link":"#👨‍💻-프로그램","children":[]},{"level":3,"title":"🏁 Kernel / 커널","slug":"🏁-kernel-커널","link":"#🏁-kernel-커널","children":[]},{"level":3,"title":"📻 Utility / 유틸리티","slug":"📻-utility-유틸리티","link":"#📻-utility-유틸리티","children":[]},{"level":3,"title":"🖥️ Shell / 쉘","slug":"🖥️-shell-쉘","link":"#🖥️-shell-쉘","children":[]},{"level":3,"title":"📁 File / 파일","slug":"📁-file-파일","link":"#📁-file-파일","children":[]},{"level":3,"title":"⌨️ Standard File / 표준 파일","slug":"⌨️-standard-file-표준-파일","link":"#⌨️-standard-file-표준-파일","children":[]},{"level":3,"title":"🧵 Kernel - Shell - Utility 관계","slug":"🧵-kernel-shell-utility-관계","link":"#🧵-kernel-shell-utility-관계","children":[]},{"level":3,"title":"🤔 Windows와 Linux의 관점 차이","slug":"🤔-windows와-linux의-관점-차이","link":"#🤔-windows와-linux의-관점-차이","children":[]},{"level":3,"title":"🪣 CPU 자원의 할당","slug":"🪣-cpu-자원의-할당","link":"#🪣-cpu-자원의-할당","children":[]},{"level":3,"title":"😅 Linux의 I/O Instruction 요청기","slug":"😅-linux의-i-o-instruction-요청기","link":"#😅-linux의-i-o-instruction-요청기","children":[]},{"level":3,"title":"🛹 Linux Manual 읽기","slug":"🛹-linux-manual-읽기","link":"#🛹-linux-manual-읽기","children":[]}]}],"git":{"createdTime":1736780312000,"updatedTime":1737382985000,"contributors":[{"name":"Chance","email":"ahs0432@naver.com","commits":7},{"name":"ahs0432","email":"ahs0432@naver.com","commits":1}]},"readingTime":{"minutes":2.82,"words":845},"filePathRelative":"posts/Computing/OS/Linux/Kernel/Kernel-Introducing.md","localizedDate":"2025년 1월 18일","excerpt":"<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">정보</p>\\n<p>📢 개인적인 정리를 위해 가벼운 어투로 내용을 정리하였습니다.</p>\\n</div>\\n<h2>🌠 2025년 마음가짐</h2>\\n<p>2025년에는 나의 부족한 점을 더 업그레이드 해보자는 마음을 갖게 됐다.<br>\\n나는 나름 여러 활동을 통해 얕지만 많은 지식을 갖고 있다고 생각하고 있다.</p>\\n<p>하지만, 내가 가장 잘하는 하나의 지식을 뽑아보라고 하면 정하기가 어려운 것 같다.<br>\\n중소기업의 장점이자 단점이 여기서 부각되는데 다양한 경험은 있지만 깊지 못하다.</p>","autoDesc":true}');export{h as comp,u as data};
