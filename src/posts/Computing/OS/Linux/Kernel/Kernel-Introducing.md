---
title:  "[Kernel] Linux Kernel 기초 [1]"

categories:
  - Linux
tags:
  - Linux

date: 2025-01-12

order: 101
editLink: false
lastUpdated: true
---

::: info
📢 개인적인 정리를 위해 가벼운 어투로 내용을 정리하였습니다.
:::

## 🌠 2025년 마음가짐
2025년에는 나의 부족한 점을 더 업그레이드 해보자는 마음을 갖게 됐다.  
나는 나름 여러 활동을 통해 얕지만 많은 지식을 갖고 있다고 생각하고 있다.  

하지만, 내가 가장 잘하는 하나의 지식을 뽑아보라고 하면 정하기가 어려운 것 같다.  
중소기업의 장점이자 단점이 여기서 부각되는데 다양한 경험은 있지만 깊지 못하다.

그래서 올해부턴 나한테 물어보면 저는 **이 분야의 전문가입니다** 하도록 노력하려 한다.  
~~(지금은 외부에 나가 이야기할 때 `클라우드 엔지니어`이자 `개발자` 지망생이라 한다.)~~

나는 어렸을 때 `시스템 프로그래머`를 동경했고 지금도 이 부분은 마찬가지인 상태다.  
지금은 기본 Base가 있고 그렇기에 목표에 도달하기에 이보다 더 나은 상태는 없다.

올해 첫 번째 도전으로 그간 겉핥기만 열심히 했던 `Kernel`에 대한 학습을 시작한다.  
솔직히 `Kernel`이라는 요소는 `개발자`, `엔지니어`에게 필수 지식은 아닐 수 있다.

`시스템 프로그래머`에게 있어 `Kernel`에 대한 구조 이해는 기본 중에 기본일 것이고,  
시간이 흘러서 이 지식은 나의 기초 체력이자 큰 원동력으로 작용할 것으로 확신한다.

## 😀 어떻게 공부할 것인가?
현재는 별세하신 서울대학교의 고건 교수님께서 배포해두신 [강의](https://olc.kr/course/course_online_view.jsp?id=35&s_keyword=kernel&x=0&y=0)를 이용할 것이다.  

이러한 강의를 조금 더 빠르게 접했다면 좋았을텐데라는 생각이 강하게 들고 있다.  
무료로 이정도 학식이 높으신 분의 강의를 접할 수 있다는 것이 정말 좋은 듯 하다.

시간 여유가 될 때 강의를 시청하고 계속 돌려보며 나의 지식으로 만들고자 한다.  
치열했던 2024년이 끝났으니 더 치열한 2025년을 살아보자라는 생각을 한다.

여기까지 강의를 듣기 전 나의 서론을 마치겠다. 너무 길어서 지루했을 듯 하다.

## 😎 Introduction
### 💫 배우기 전에
`Kernel`이란 분야는 한 명이 마스터하여 모든 것을 알기란 어려운 분야다.  

`Linux`를 굉장히 잘 다루는 집단으로 유명한 `IBM`과 같은 공룡 기업에서도  
총 250명 정도의 인원으로 각 분야 별 전문가 그룹을 운영하고 있을 정도이다.

그렇기에 기초를 다질 때에는 `Kernel`에 대한 모든 구조를 알겠다라는 것보단  
`Kernel`과 `운영체제`가 어떻게 설계됐고 그에 대한 원리를 이해하도록 하자.

### ☸️ 운영체제
`운영체제`라는 것을 사용자와 컴퓨터 하드웨어 간 중재자 역할을 하는 프로그램이다.  
조금 더 정리해보면 `하드웨어 자원`을 관리하고 사용자에게 지원하는 서비스이다.

::: info
🦾 **하드웨어 자원의 종류?**  
`하드웨어`는 굉장히 다양한 종류가 존재하는데 대표적으로 아래와 같이 이뤄져 있다.  

- `CPU`(`Central Process Unit`, `중앙처리장치`): 기억, 해석, 연산, 제어 수행
- `Memory`(`주기억장치`): `CPU`와 `Disk` 간 속도 차이 해소 / `휘발성` / `RAM`
- `Disk`(`보조기억장치`): 실제 데이터를 저장하는 공간 / `비휘발성` / `SSD`, `HDD`
- `TTY`(`TeleTYpewriter`): `Console` 및 `Terminal` 모드를 의미
  - `TTS`(`TTy Serial`): `Console`을 이용한 물리적인 접근을 지원
  - `PTY`(`Pseudo-Terminal`): Pseudo(가상)의 `Teminal` 모드 (`CLI`)
  - `PTS`(`Pseudo-Terminal Slave`): Pseudo(가상)의 `Teminal` 모드 (`GUI`)

이외에도 다양한 `하드웨어`가 있고 이러한 자원을 `운영체제`에서 관리하게 된다.
:::

#### 목표
`운영체제`의 목표는 간단하게 4가지로 정리하여 설명할 수 있다.
- 사용자의 프로그램을 실행한다.
- 사용자 문제를 더 쉽게 해결할 수 있도록 지원한다.
- 컴퓨터 시스템을 편리하게 사용할 수 있도록 제공한다.
- 하드웨어를 더욱 효율적으로 사용할 수 있도록 한다.

#### 성능 지표
결국 목표에 대한 달성에 대한 부분을 평가하기 위해서는 지표가 필요할 것이다.  
`운영체제`에서 사용하게 되는 지표는 대표적으로 아래의 3가지가 존재할 것이다.

- `처리량`(`Throughput`): 작업/초 (`시스템 중심`)
- `활용도`(`Utilization`): 사용 시간의 비율 (`사용자 중심`)
- `응답시간`(`Response Time`): 작업 당 시간 (`사용자 중심`)

지표는 `사용자 중심`과 `시스템 중심`으로 나눌 수 있는데 서로 충돌될 수 있다.

#### 구조
`사용자` &rarr; `응용 프로그램` &rarr; `운영체제` &rarr; `하드웨어`

구조를 보면 이해할 수 있겠지만 `사용자`가 `응용 프로그램`을 사용하게 될 경우  
`운영체제`를 통해 `하드웨어`를 이용한 요청을 수행한다는 것을 확인할 수 있다.

### 👨‍💻 프로그램
`프로그램`은 어떠한 일을 수행하기 위해 작성된 순서나 목록 등을 의미하게 되는데,  
다양한 기능들의 `함수`(`명령`)를 이용하여 순서나 목록을 작성한 집합체라 볼 수 있다.
- 대표적으로 `C Language`를 이용하여 코드 작성 시 `*.c` 파일을 작성하게 되는데,  
  이를 `컴파일`(`Compile`)한 `a.out`, `a.exe` 등의 목적 파일을 프로그램이라 칭함

#### 프로그램의 비효율성
우리가 많이 사용하는 Microsoft 사에서 개발한 `Office`라는 프로그램을 생각해보자.  

`Office`는 하나의 프로그램이 아닌 `Word`, `Excel`, `Powerpoint` 등으로 분리돼있다.  
**왜 그렇게 분리 해두었을까?** 다양한 이유가 있겠지만 `비효율성`이 클 것이라 생각된다.  
~~(물론 사업적인 목적에서 분리하여 별도로 판매하려는 목적도 있을 것이라 생각한다.)~~

`프로그램`이 커지게 되면 실행하게 될 때 `하드웨어`에 부담되는 `사용량`이 증가한다.  
그렇게 된다면 자원 사용량이 늘어나니 당연하게도 **동작 속도의 저하로 이어지게 된다.**

사람으로 비유해보면 한 사람에게 불필요한 업무까지 모두 전달하는 경우로 볼 수 있다.  

#### 운영체제의 프로그램 분리
`프로그램`이 하나의 큰 요소에서 `비효율성`이 있다면 `운영체제`도 마찬가지일 것이다.  
이러한 `비효율성`을 해소하기 위해 `운영체제`도 여러 요소로 분리하여 제공하고 있다.

대표적인 요소로 `Kernel`, `Utility`, `Shell`, `File`, `Standard File` 정도가 있다.  

### 🏁 Kernel / 커널
`Kernel`은 본질적으로 `C Language`로 만들어진 `프로그램`에 해당하는 요소이다.  
다른 것과 무슨 차이점이 있길래 `Kernel`이라는 별도의 요소로 부르게 된 것일까?

바로 `Memory Resident`하다는 특징을 가지고 있기 때문에 별도로 구분하게 된다.  
`Memory Resident`는 직역하게 되면 `메모리 거주자`(?)정도라고 이야기할 수 있다.

`Kernel`은 다른 `프로그램`과 다르게 `Memory`에 항상 상주(점유)하고 있게 된다.  
그렇기 때문에 무언가 처리가 필요할 때 즉각적으로 대응할 수 있다는 특징이 있다.

그렇다면 `Kernel` 외의 `프로그램`은 어떠한 특징을 가지고 있다고 볼 수 있을까?  
눈치챈 사람도 있겠지만 `Disk Resident`한 특징을 갖고 있다고 이야기할 수 있다.

다른 `프로그램`은 `Disk`에 있다가 필요한 경우 `Memory`에 상주하여 처리한다.  

### 📻 Utility / 유틸리티
`Utility`는 `Kernel`에서 알아본 바와 같이 `Disk Resident`한 특징을 갖는다.  
필요한 경우에 `Disk`에서 `Memory`로 상주시키고 종료되면 회수된다는 것이다.

우리가 `CLI` 환경에서 필요한 경우 호출되고 사용하는 요소가 무엇이 있을까?  
그렇다 바로 `Command`라는 요소가 존재하는데, `Utility`와 동의어로 본다.  
(보통 `Linux`에서 `Command`라는 것은 `/bin/` 경로 하위에 위치하게 된다.)

그리고 이것은 하나의 `Job`(`작업`)이라고도 이야기할 수 있다.  
(`Utility` = `Command` = `Job`이라는 관계로 볼 수 있다.)

### 🖥️ Shell / 쉘쉘
`Shell`은 `Utility`지만 `Job Control`(`작업 제어`)라는 특징을 갖는다.  
이전에 `Utility`는 하나의 `Job`이라고 부를 수 있다고 이야기 했었다.  

`Shell`은 `Utility`를 제어하는 역할을 수행한다고 볼 수 있는 것이다.  
(`Command`마다 처리를 진행하므로 `Interpreter` 역할이라 볼 수 있다.)

주된 역할은 키보드 입력을 읽고 명령을 실행하고 결과를 반환하게 된다.  
`사용자`와 `UNIX/Linux` 간의 인터페이스 역할을 수행한다고 볼 수 있다.

### 📁 File / 파일
`Sequence of Bytes`로 **바이트의 연속체(배열)** 정도로 해석이 가능하다.  
정보의 이름이 지정된 집합체 정도로 블록과 같은 제약이 존재하지 않는다.

또한 `Linux`와 같은 `운영체제`는 **I/O Device**도 `File`로 취급하게 된다.  
`Linux` 시스템 상 `/dev/` 하위에는 **특수 파일(Special files)**이 있다.
- 예) `/dev/xvda`, `/dev/tty0`

### ⌨️ Standard File / 표준 파일
`Linux`와 같은 `운영체제`는 I/O Device도 `File`로 취급한다는 걸 알게 됐다.  

이러한 표준 형식으로 제공되는 요소를 `Standard File`이라고 일컫게 되는데,  
보통은 `표준 입력`, `표준 출력`, `표준 오류`와 같이 3가지 요소로 나누게 된다.

- `표준 입력`(`Standard Input`): 키보드
- `표준 출력`(`Standard Output`): 화면
- `표준 오류`(`Standard Error`): 오류 메시지

### 🧵 Kernel - Shell - Utility 관계
이 세 요소에 대한 관계를 이해하기 위해서는 전개되는 과정을 이해할 필요가 있다.

- `Booting`을 통해 시스템을 실행한다.
  - `Kernel`이 실행되어 `Memory`에 상주한다.
- `Shell`을 이용하여 사용자가 접근하게 된다.
  - `Kernel` 하위에 `Child Process`로 `Shell`이 실행된다.
  - `Shell`도 마찬가지로 `Memory`에 상주하게 된다.
  - `사용자`가 `Command`를 입력할 때까지 대기한다.
- `Utility`(`Command`)를 실행한다.
  - `Shell` 하위에 `Child Process`로 `Utility`가 실행된다.
  - `Utility`도 `Memory`에 상주하고 `Job`이 끝나면 회수된다.
- `사용자`가 모든 작업을 끝내고 `Shell`을 종료한다.
  - `Shell`이 상주했던 `Memory`가 회수된다.

이 과정으로 보면 아래와 같은 Tree 구조 형태를 가지게 된다고 볼 수 있다.

```
Kernel
├── Shell (1)
│   ├── Utility (2-1)
│   └── Utility (2-2)
└── Shell (2)
    ├── Utility (2-1)
    └── Utility (2-2)
```

- - -

아직 이게 1강인게 놀랍다. 소개에 대한 부분만 이정도의 분량이 나오게 된다.  
얼마나 깊고 심오한 세상일까 다시 한번 놀라면서 더 열심히 하자는 생각이 든다.  

2025년 열심히 달려보자.